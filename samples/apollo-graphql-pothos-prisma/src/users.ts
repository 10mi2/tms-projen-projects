/* eslint-disable dot-notation */
import { queryFromInfo } from "@pothos/plugin-prisma";
import { z } from "zod";
import { builder } from "./builder.js";
import {
  PostConnection,
  PostOrderByInput,
  UserPostCursorSchema,
  postSortConfigs,
} from "./posts.js";
import { decodeAndCheckID, encodeID } from "./util/id-handling.js";
import {
  CursorSort,
  getCursorProperties,
  makeCursorSchema,
} from "./util/pagination-cursor.js";
import {
  Connection,
  commonPaginationArgs,
  makePagination,
} from "./util/pagination.js";

// Handling of User IDs
export const encodeUserID = (id: number) => encodeID({ user: id });
export const decodeUserID = (id: string) =>
  decodeAndCheckID(id, z.object({ user: z.number() }).strict()).user;

// User Object - with paginated posts
export const userWithPaginatedPosts = builder.prismaObject("User", {
  name: "UserWithPaginatedPosts",
  description: "A user with paginated posts",
  // specify minimum select fields for the Prisma object
  // other fields that are requested will be added to the select
  // See: https://pothos-graphql.dev/docs/plugins/prisma#select-mode-for-types
  select: {
    id: true,
    name: true,
  },
  fields: (t) => {
    return {
      id: t.field({
        type: "ID",
        nullable: false,
        resolve: (parent) => encodeUserID(parent.id),
      }),
      name: t.exposeString("name", { nullable: true }),
      email: t.exposeString("email"),
      test: t.string({ resolve: () => "test" }),

      // Connection to the user's posts
      posts: t.field({
        type: PostConnection,
        args: {
          ...commonPaginationArgs(t.arg, PostOrderByInput, "title"),
        },

        // specify minimum select fields for the Prisma object
        // here we're also specifying how to resolve the posts - this will shape the Prisma query generated by Pothos
        select: (args, _context, nestedSelection) => {
          // Get cursor properties from arguments
          const { orderBy, cursorWhere, take } = getCursorProperties(
            args,
            postSortConfigs,

            // Zod schema to validate the cursor against
            UserPostCursorSchema,
          );

          // Using nestedSelection to get the selections for the posts, putting in properties from the given Post cursor
          // See https://pothos-graphql.dev/docs/plugins/prisma#selecting-fields-from-a-nested-graphql-field
          return {
            posts: nestedSelection(
              {
                select: {
                  id: true,

                  // must include any fields we *might* sort on, even if the client doesn't ask for them
                  title: true,
                },
                where: {
                  ...cursorWhere,
                },
                orderBy: orderBy,
                take,
              },
              // Look at the selections in posts.edges.node to determine what relations/fields to select
              ["edges", "node"],
            ),
          };
        },
        resolve: (user, args) => {
          // Get cursor properties from arguments, including the context for making the cursors in the connection
          const { sort, reverse } = getCursorProperties(
            args,
            postSortConfigs,
            UserPostCursorSchema,
            {
              authorId: user.id,
            },
          );

          return new Connection(
            "userPost",
            !reverse ? user.posts : user.posts.reverse(),
            sort,
            [{ key: "authorId", value: user.id }],
          );
        },
      }),
    };
  },
});

const UserOrderByInput = builder.enumType("UserOrderByInput", {
  description: "Options for sorting Users",
  values: {
    ID: { value: "id" },
    NAME: { value: "name" },
    EMAIL: { value: "email" },
  } as const,
});

const { connection: UserConnection } = makePagination(userWithPaginatedPosts);

export const CreateUserInput = builder.inputType("CreateUserInput", {
  description: "Input for new users",
  fields: (t) => ({
    name: t.string({ required: true }),
    email: t.string({ required: true }),
  }),
});

// const UpdateUserInput =
// builder.inputType("UpdateUserInput", {
//   description: "Input for updating users",
//   fields: (t) => ({
//     name: t.string({}),
//     email: t.string({}),
//   }),
// });

export const userSortConfigs = {
  id: [{ key: "id" }],
  name: [{ key: "name" }, { key: "id" }],
  email: [{ key: "email" }, { key: "name" }, { key: "id" }],
} satisfies Record<string, CursorSort>;

const UserCursorValueSchema = z.discriminatedUnion("key", [
  z.object({
    sort: z.enum(["a", "d"]).optional(),
    key: z.enum(["name", "email"] as const),
    value: z.string(),
  }),
  z.object({
    sort: z.enum(["a", "d"]).optional(),
    key: z.literal("id"),
    value: z.number(),
  }),
]);
const UserCursorSchema = makeCursorSchema("user", UserCursorValueSchema);

// Query and Mutation fields for Users
builder.queryFields((t) => ({
  users: t.field({
    type: UserConnection,
    args: {
      // Optional ID argument to get a specifc User
      id: t.arg.id(),

      // Pagination arguments
      ...commonPaginationArgs(t.arg, UserOrderByInput, "name"),
    },
    resolve: async (_parent, args, context, info) => {
      // Get cursor properties from arguments
      const { orderBy, cursorWhere, take, sort, reverse } = getCursorProperties(
        args,
        userSortConfigs,

        // Zod schema to validate the cursor against
        UserCursorSchema,
        // Context for cursor, will be used in making the where clause from the cursor
        typeof args.id === "string"
          ? {
              id: decodeUserID(args.id),
            }
          : undefined,
      );

      const queryArgs = {
        ...queryFromInfo({
          context,
          info,
          // nested path where the selections for this type can be found
          path: ["edges", "node"],
        }),
        where: {
          ...cursorWhere,
        },
        orderBy,
        take,
      };

      // Get the users, using the cursor properties
      // Note if we are reversing the order, we will do that below, not here
      const users = await context.prisma.user.findMany(queryArgs);

      // Return the Users as a Connection
      return new Connection("user", !reverse ? users : users.reverse(), sort);
    },
  }),
}));

builder.mutationFields((t) => ({
  createUser: t.prismaField({
    type: userWithPaginatedPosts,
    description: "Create a new user",
    args: {
      input: t.arg({
        type: CreateUserInput,
        required: true,
      }),
    },
    resolve: async (query, _parent, args, context) => {
      // query is generated by Pothos and containes the Prisma query values (where, etc) for the response shape
      const user = await context.prisma.user.create({
        ...query,
        data: args.input,
      });
      return user;
    },
  }),
  deleteUser: t.prismaField({
    type: userWithPaginatedPosts,
    description: "Delete a user",
    args: {
      id: t.arg.id({ required: true }),
    },
    resolve: async (query, _parent, args, context) => {
      const id = decodeUserID(args.id);
      // query is generated by Pothos and containes the Prisma query values (where, etc) for the response shape
      const user = await context.prisma.user.delete({
        ...query,
        where: {
          id,
        },
      });
      return user;
    },
  }),
}));
